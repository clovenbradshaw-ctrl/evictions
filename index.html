<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Eviction State Fetcher</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', monospace;
    background: #0a0e17;
    color: #c8d3e0;
    min-height: 100vh;
    padding: 24px;
  }

  .label {
    font-size: 11px;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: #4a6fa5;
    margin-bottom: 4px;
  }

  h1 {
    font-size: 22px;
    font-weight: 700;
    color: #e8edf3;
    letter-spacing: -0.5px;
    margin-bottom: 4px;
  }

  .url {
    font-size: 11px;
    color: #3d5a80;
    margin-bottom: 20px;
    word-break: break-all;
  }

  .controls {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }

  button {
    padding: 8px 20px;
    border: none;
    border-radius: 4px;
    font-size: 12px;
    font-family: inherit;
    cursor: pointer;
    font-weight: 600;
    transition: opacity 0.15s;
  }

  button:hover { opacity: 0.85; }

  .btn-primary {
    background: #1b6ef3;
    color: #fff;
  }

  .btn-primary:disabled {
    background: #1a2436;
    color: #3d5a80;
    cursor: not-allowed;
  }

  .btn-stop {
    background: transparent;
    color: #e05555;
    border: 1px solid #e05555;
  }

  .btn-ghost {
    background: transparent;
    color: #4a6fa5;
    border: 1px solid #1e2d44;
  }

  .status-bar {
    display: flex;
    gap: 24px;
    margin-bottom: 20px;
    font-size: 12px;
    color: #4a6fa5;
  }

  .status-bar .val { color: #e8edf3; font-weight: 600; }
  .status-bar .fetching { color: #f5c542; }
  .status-bar .done { color: #34d399; }
  .status-bar .error { color: #e05555; }

  .progress-wrap {
    height: 3px;
    background: #111827;
    border-radius: 2px;
    margin-bottom: 20px;
    overflow: hidden;
  }

  .progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #1b6ef3, #34d399);
    transition: width 0.3s;
    border-radius: 2px;
  }

  .progress-bar.indeterminate {
    width: 60%;
    animation: pulse 1.5s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.4; }
    50% { opacity: 1; }
  }

  .log {
    background: #0d1220;
    border: 1px solid #151d2e;
    border-radius: 4px;
    padding: 12px;
    margin-bottom: 20px;
    max-height: 160px;
    overflow: auto;
    font-size: 11px;
    line-height: 1.7;
  }

  .log-line { color: #4a6fa5; }
  .log-line.ok { color: #34d399; }
  .log-line.err { color: #e05555; }

  .error-box {
    background: #1a0a0a;
    border: 1px solid #3a1515;
    border-radius: 4px;
    padding: 12px;
    margin-bottom: 20px;
    font-size: 12px;
    color: #e05555;
  }

  .table-wrap {
    border: 1px solid #151d2e;
    border-radius: 4px;
    overflow: auto;
    max-height: 50vh;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 11px;
  }

  th {
    padding: 8px 10px;
    text-align: left;
    border-bottom: 1px solid #1e2d44;
    color: #4a6fa5;
    font-weight: 600;
    position: sticky;
    top: 0;
    background: #0d1220;
    white-space: nowrap;
    z-index: 1;
  }

  td {
    padding: 6px 10px;
    border-bottom: 1px solid #111827;
    white-space: nowrap;
    max-width: 220px;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  tr.even { background: transparent; }
  tr.odd { background: #0c1019; }
  tr.clickable { cursor: pointer; }
  tr.clickable:hover { background: #111827; }

  .expanded-cell {
    padding: 12px;
    background: #0d1220;
    border-bottom: 1px solid #151d2e;
  }

  .expanded-cell pre {
    margin: 0;
    font-size: 10px;
    color: #7a8ea8;
    white-space: pre-wrap;
    word-break: break-all;
    font-family: inherit;
  }

  .table-footer {
    padding: 12px;
    font-size: 11px;
    color: #3d5a80;
    text-align: center;
  }

  .hidden { display: none; }

  ::-webkit-scrollbar { width: 6px; height: 6px; }
  ::-webkit-scrollbar-track { background: #0a0e17; }
  ::-webkit-scrollbar-thumb { background: #1e2d44; border-radius: 3px; }
</style>
</head>
<body>

<div class="label">Ground Truth Nashville</div>
<h1>Eviction State Fetcher</h1>
<div class="url" id="apiUrl"></div>

<div class="controls">
  <button class="btn-primary" id="btnFetch" onclick="fetchAll()">Fetch All Pages</button>
  <button class="btn-stop hidden" id="btnStop" onclick="stopFetch()">Stop</button>
  <button class="btn-ghost hidden" id="btnJSON" onclick="exportJSON()">Export JSON</button>
  <button class="btn-ghost hidden" id="btnCSV" onclick="exportCSV()">Export CSV</button>
</div>

<div class="status-bar">
  <span>Status: <span id="statusText" class="val">Ready</span></span>
  <span>Records: <span id="recordCount" class="val">0</span></span>
</div>

<div class="progress-wrap hidden" id="progressWrap">
  <div class="progress-bar indeterminate" id="progressBar"></div>
</div>

<div class="log hidden" id="logBox"></div>
<div class="error-box hidden" id="errorBox"></div>
<div class="table-wrap hidden" id="tableWrap">
  <table>
    <thead id="thead"></thead>
    <tbody id="tbody"></tbody>
  </table>
  <div class="table-footer hidden" id="tableFooter"></div>
</div>

<script>
const API_BASE = "https://xvkq-pq7i-idtl.n7d.xano.io/api:3CsVHkZK/eviction_current_state";
const PER_PAGE = 2500;
const MAX_TABLE_ROWS = 200;

// Schema: { id, created_at, docket_number, updated, stateData: [json], fileDate }
// stateData entries: { op, ts, Office, Status, source, Attorney, File_Date, Description, individual_ll, Defendant_Respondent, Plaintiff_Petitioner }

const TABLE_COLUMNS = [
  { key: "docket_number",        label: "Docket" },
  { key: "fileDate",             label: "File Date" },
  { key: "Status",               label: "Status",      from: "stateData" },
  { key: "Plaintiff_Petitioner", label: "Plaintiff",   from: "stateData" },
  { key: "Defendant_Respondent", label: "Defendant",   from: "stateData" },
  { key: "Attorney",             label: "Attorney",    from: "stateData" },
  { key: "Description",          label: "Description", from: "stateData" },
];

let records = [];
let abortController = null;
let expandedRow = null;

document.getElementById("apiUrl").textContent = API_BASE;

function $(id) { return document.getElementById(id); }
function show(id) { $(id).classList.remove("hidden"); }
function hide(id) { $(id).classList.add("hidden"); }

function addLog(msg) {
  show("logBox");
  const div = document.createElement("div");
  div.className = "log-line" + (msg.includes("\u2713") ? " ok" : msg.includes("\u2717") ? " err" : "");
  div.textContent = new Date().toLocaleTimeString() + " \u2014 " + msg;
  $("logBox").appendChild(div);
  $("logBox").scrollTop = $("logBox").scrollHeight;
}

function truncate(val, len) {
  if (val === null || val === undefined) return "\u2014";
  const s = typeof val === "object" ? JSON.stringify(val) : String(val);
  return s.length > len ? s.slice(0, len) + "\u2026" : s;
}

function setStatus(text, cls) {
  const el = $("statusText");
  el.textContent = text;
  el.className = "val " + (cls || "");
}

// Parse stateData: could be a JSON string or already an array
function parseStateData(raw) {
  if (Array.isArray(raw)) return raw;
  if (typeof raw === "string") {
    try { return JSON.parse(raw); } catch (e) { return []; }
  }
  return [];
}

// Get the latest event from the stateData array (last entry = current state)
function latestState(record) {
  const events = parseStateData(record.stateData);
  return events.length > 0 ? events[events.length - 1] : {};
}

// Format a timestamp field for display (epoch ms or date string)
function formatDate(val) {
  if (val == null) return "\u2014";
  if (typeof val === "number") {
    return new Date(val).toISOString().slice(0, 10);
  }
  const s = String(val);
  // Already a date string like "2025-02-26"
  if (/^\d{4}-\d{2}-\d{2}/.test(s)) return s.slice(0, 10);
  // Epoch as string
  const n = Number(s);
  if (!isNaN(n) && s.length >= 10) return new Date(n).toISOString().slice(0, 10);
  return s;
}

// Get a display value for a column from a record
function getColValue(record, col) {
  if (col.from === "stateData") {
    return latestState(record)[col.key] ?? null;
  }
  if (col.key === "fileDate") return formatDate(record.fileDate);
  return record[col.key] ?? null;
}

function updateTable() {
  if (records.length === 0) return;

  $("thead").innerHTML = "<tr><th>#</th>" +
    TABLE_COLUMNS.map(c => `<th>${c.label}</th>`).join("") +
    "<th></th></tr>";

  show("tableWrap");
  const display = records.slice(0, MAX_TABLE_ROWS);
  $("tbody").innerHTML = display.map((r, i) => {
    const cls = (i % 2 === 0 ? "even" : "odd") + " clickable";
    const arrow = expandedRow === i ? "\u25B2" : "\u25BC";
    let row = `<tr class="${cls}" onclick="toggleRow(${i})">` +
      `<td>${i + 1}</td>` +
      TABLE_COLUMNS.map(c => {
        const val = getColValue(r, c);
        const est = (c.key === "fileDate" && r._fileDateEstimated);
        const d = truncate(val, 40);
        if (est) return `<td style="color:#f5c542" title="Estimated from neighbors">~${d}</td>`;
        if (c.key === "Status" && val) {
          const color = val === "PENDING" ? "#f5c542" : val === "CLOSED" ? "#34d399" : "#c8d3e0";
          return `<td style="color:${color}">${d}</td>`;
        }
        return `<td>${d}</td>`;
      }).join("") +
      `<td style="color:#3d5a80">${arrow}</td></tr>`;
    if (expandedRow === i) {
      const state = latestState(r);
      const detail = {
        id: r.id,
        created_at: formatDate(r.created_at),
        docket_number: r.docket_number,
        updated: formatDate(r.updated),
        fileDate: formatDate(r.fileDate),
        _fileDateEstimated: r._fileDateEstimated || false,
        stateData_events: parseStateData(r.stateData).length,
        current_state: state,
      };
      row += `<tr><td colspan="${TABLE_COLUMNS.length + 2}" class="expanded-cell"><pre>${JSON.stringify(detail, null, 2)}</pre></td></tr>`;
    }
    return row;
  }).join("");

  if (records.length > MAX_TABLE_ROWS) {
    show("tableFooter");
    $("tableFooter").textContent = `Showing ${MAX_TABLE_ROWS} of ${records.length.toLocaleString()} records. Export to see all.`;
  }
}

function toggleRow(i) {
  expandedRow = expandedRow === i ? null : i;
  updateTable();
}

async function fetchAll() {
  records = [];
  expandedRow = null;
  $("logBox").innerHTML = "";
  $("thead").innerHTML = "";
  $("tbody").innerHTML = "";
  hide("errorBox");
  hide("tableFooter");

  $("btnFetch").disabled = true;
  show("btnStop");
  hide("btnJSON");
  hide("btnCSV");
  show("progressWrap");

  $("recordCount").textContent = "0";

  abortController = new AbortController();
  let offset = 0;
  let keepGoing = true;
  let itemsTotal = null;
  const MAX_FETCHES = 500;
  let fetchCount = 0;

  try {
    while (keepGoing && fetchCount < MAX_FETCHES) {
      if (abortController.signal.aborted) break;
      fetchCount++;

      const url = `${API_BASE}?offset=${offset}&per_page=${PER_PAGE}`;
      addLog(`Fetching offset ${offset}...`);
      setStatus(`${records.length.toLocaleString()}${itemsTotal ? " / " + itemsTotal.toLocaleString() : ""} records`, "fetching");

      let res, data;
      const MAX_RETRIES = 3;
      for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        try {
          res = await fetch(url, { signal: abortController.signal });
          if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
          data = await res.json();
          break;
        } catch (fetchErr) {
          if (fetchErr.name === "AbortError") throw fetchErr;
          if (attempt < MAX_RETRIES) {
            const wait = attempt * 2000;
            addLog(`Retry ${attempt}/${MAX_RETRIES} in ${wait / 1000}s \u2014 ${fetchErr.message}`);
            await new Promise(r => setTimeout(r, wait));
          } else {
            throw fetchErr;
          }
        }
      }

      // Xano paginated wrapper
      if (data && typeof data === "object" && !Array.isArray(data) && Array.isArray(data.items)) {
        const items = data.items;
        const received = items.length;
        records.push(...items);

        if (data.itemsTotal) itemsTotal = data.itemsTotal;
        const perPage = data.perPage || PER_PAGE;

        // Progress based on records collected vs total
        if (itemsTotal) {
          const pct = Math.min((records.length / itemsTotal) * 100, 100);
          $("progressBar").classList.remove("indeterminate");
          $("progressBar").style.width = pct + "%";
        }

        addLog(`Got ${received} records (${records.length.toLocaleString()}${itemsTotal ? " / " + itemsTotal.toLocaleString() : ""})`);

        // PRIMARY stop: collected enough records
        if (received === 0
            || (itemsTotal && records.length >= itemsTotal)) {
          keepGoing = false;
        } else {
          offset += received;
        }
      }
      // Plain array
      else if (Array.isArray(data)) {
        records.push(...data);
        addLog(`Got ${data.length} records (${records.length.toLocaleString()})`);
        if (data.length === 0 || data.length < PER_PAGE) {
          keepGoing = false;
        } else {
          offset += data.length;
        }
      }
      // Unknown
      else {
        addLog(`Unexpected response shape. Keys: ${Object.keys(data || {}).join(", ")}`);
        addLog(`Raw: ${JSON.stringify(data).slice(0, 500)}`);
        keepGoing = false;
      }

      $("recordCount").textContent = records.length.toLocaleString();
      updateTable();

      if (keepGoing) await new Promise(r => setTimeout(r, 1000));
    }

    addLog(`\u2713 Fetched ${records.length.toLocaleString()} records. Inferring missing fileDates...`);
    inferMissingFileDates();
    addLog(`\u2713 Complete.`);
    setStatus("Complete", "done");
  } catch (err) {
    if (err.name === "AbortError") {
      addLog("Fetch cancelled by user.");
      setStatus("Stopped", "");
    } else {
      addLog(`\u2717 Error: ${err.message}`);
      setStatus("Error", "error");
      $("errorBox").textContent = err.message;
      show("errorBox");
    }
  }

  $("btnFetch").disabled = false;
  hide("btnStop");
  hide("progressWrap");

  if (records.length > 0) {
    show("btnJSON");
    show("btnCSV");
  }
}

function parseDocket(dn) {
  // e.g. "25GT14532" -> { prefix: "25GT", seq: 14532 }
  // e.g. "26GT625"   -> { prefix: "26GT", seq: 625 }
  const m = dn && dn.match(/^(\d{2}[A-Z]+)(\d+)$/i);
  if (!m) return null;
  return { prefix: m[1].toUpperCase(), seq: parseInt(m[2], 10) };
}

function inferMissingFileDates() {
  // 1. Parse all docket numbers and collect known fileDate anchors per prefix group
  const parsed = records.map((r, i) => ({
    idx: i,
    docket: parseDocket(r.docket_number),
    fileDate: r.fileDate || null,
  }));

  // Group by prefix (e.g. "25GT", "26GT")
  const groups = {};
  for (const p of parsed) {
    if (!p.docket) continue;
    const key = p.docket.prefix;
    if (!groups[key]) groups[key] = [];
    groups[key].push(p);
  }

  let filled = 0;
  let skipped = 0;

  for (const [prefix, items] of Object.entries(groups)) {
    // Sort by sequence number
    items.sort((a, b) => a.docket.seq - b.docket.seq);

    // Collect anchors: items with known fileDate
    const anchors = [];
    for (const item of items) {
      if (item.fileDate != null) {
        // fileDate could be epoch ms (number), epoch string, or date string
        let ts;
        if (typeof item.fileDate === "number") {
          ts = item.fileDate;
        } else if (typeof item.fileDate === "string") {
          const n = Number(item.fileDate);
          if (!isNaN(n) && item.fileDate.length >= 10) {
            ts = n;
          } else {
            ts = new Date(item.fileDate).getTime();
          }
        }
        if (ts && !isNaN(ts)) {
          anchors.push({ seq: item.docket.seq, ts });
        }
      }
    }

    if (anchors.length === 0) {
      skipped += items.filter(i => !i.fileDate).length;
      continue;
    }

    // Sort anchors by seq
    anchors.sort((a, b) => a.seq - b.seq);

    // 2. For each item missing fileDate, interpolate from nearest anchors
    for (const item of items) {
      if (item.fileDate != null) continue;
      const seq = item.docket.seq;

      // Find the anchor just below and just above
      let below = null, above = null;
      for (let i = 0; i < anchors.length; i++) {
        if (anchors[i].seq <= seq) below = anchors[i];
        if (anchors[i].seq >= seq && above === null) above = anchors[i];
      }

      let estimatedTs;
      if (below && above && below.seq !== above.seq) {
        // Linear interpolation
        const frac = (seq - below.seq) / (above.seq - below.seq);
        estimatedTs = below.ts + frac * (above.ts - below.ts);
      } else if (below) {
        estimatedTs = below.ts;
      } else if (above) {
        estimatedTs = above.ts;
      } else {
        continue;
      }

      // Store as epoch ms (same format), flag as estimated
      const estDate = new Date(Math.round(estimatedTs));
      // Write back to the record -- store as ISO string with marker
      records[item.idx].fileDate = estDate.toISOString().slice(0, 10);
      records[item.idx]._fileDateEstimated = true;
      filled++;
    }

    addLog(`[${prefix}] ${anchors.length} anchors \u2192 inferred ${items.filter(i => records[i.idx]._fileDateEstimated).length} dates`);
  }

  addLog(`fileDate: ${filled} inferred, ${skipped} skipped (no anchors in group)`);
  updateTable();
}

function stopFetch() {
  if (abortController) abortController.abort();
}

function exportJSON() {
  // Export with flattened current state for each record
  const out = records.map(r => {
    const state = latestState(r);
    return {
      id: r.id,
      created_at: r.created_at,
      docket_number: r.docket_number,
      updated: r.updated,
      fileDate: r.fileDate,
      _fileDateEstimated: r._fileDateEstimated || false,
      status: state.Status || null,
      plaintiff: state.Plaintiff_Petitioner || null,
      defendant: state.Defendant_Respondent || null,
      attorney: state.Attorney || null,
      description: state.Description || null,
      office: state.Office || null,
      individual_ll: state.individual_ll ?? null,
      stateData_raw: r.stateData,
    };
  });
  const blob = new Blob([JSON.stringify(out, null, 2)], { type: "application/json" });
  dl(blob, `eviction_data_${today()}.json`);
}

function exportCSV() {
  if (!records.length) return;
  const CSV_COLS = [
    "id", "created_at", "docket_number", "updated", "fileDate", "_fileDateEstimated",
    "Status", "Plaintiff_Petitioner", "Defendant_Respondent", "Attorney",
    "Description", "Office", "individual_ll", "File_Date", "source", "op", "stateData_events"
  ];
  const lines = [CSV_COLS.join(",")];
  for (const r of records) {
    const state = latestState(r);
    const vals = [
      r.id,
      formatDate(r.created_at),
      r.docket_number,
      formatDate(r.updated),
      formatDate(r.fileDate),
      r._fileDateEstimated || false,
      state.Status,
      state.Plaintiff_Petitioner,
      state.Defendant_Respondent,
      state.Attorney,
      state.Description,
      state.Office,
      state.individual_ll,
      state.File_Date,
      state.source,
      state.op,
      parseStateData(r.stateData).length,
    ];
    lines.push(vals.map(v => {
      const s = v == null ? "" : String(v);
      return (s.includes(",") || s.includes('"') || s.includes("\n"))
        ? `"${s.replace(/"/g, '""')}"` : s;
    }).join(","));
  }
  const blob = new Blob([lines.join("\n")], { type: "text/csv" });
  dl(blob, `eviction_data_${today()}.csv`);
}

function dl(blob, name) {
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  URL.revokeObjectURL(a.href);
}

function today() {
  return new Date().toISOString().slice(0, 10);
}
</script>
</body>
</html>
