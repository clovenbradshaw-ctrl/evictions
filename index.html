<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Eviction State Fetcher</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'JetBrains Mono', 'Fira Code', 'SF Mono', monospace;
    background: #0a0e17;
    color: #c8d3e0;
    min-height: 100vh;
    padding: 24px;
  }

  .label {
    font-size: 11px;
    letter-spacing: 3px;
    text-transform: uppercase;
    color: #4a6fa5;
    margin-bottom: 4px;
  }

  h1 {
    font-size: 22px;
    font-weight: 700;
    color: #e8edf3;
    letter-spacing: -0.5px;
    margin-bottom: 4px;
  }

  .url {
    font-size: 11px;
    color: #3d5a80;
    margin-bottom: 20px;
    word-break: break-all;
  }

  .controls {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }

  button {
    padding: 8px 20px;
    border: none;
    border-radius: 4px;
    font-size: 12px;
    font-family: inherit;
    cursor: pointer;
    font-weight: 600;
    transition: opacity 0.15s;
  }

  button:hover { opacity: 0.85; }

  .btn-primary {
    background: #1b6ef3;
    color: #fff;
  }

  .btn-primary:disabled {
    background: #1a2436;
    color: #3d5a80;
    cursor: not-allowed;
  }

  .btn-stop {
    background: transparent;
    color: #e05555;
    border: 1px solid #e05555;
  }

  .btn-ghost {
    background: transparent;
    color: #4a6fa5;
    border: 1px solid #1e2d44;
  }

  .status-bar {
    display: flex;
    gap: 24px;
    margin-bottom: 20px;
    font-size: 12px;
    color: #4a6fa5;
  }

  .status-bar .val { color: #e8edf3; font-weight: 600; }
  .status-bar .fetching { color: #f5c542; }
  .status-bar .done { color: #34d399; }
  .status-bar .error { color: #e05555; }

  .progress-wrap {
    height: 3px;
    background: #111827;
    border-radius: 2px;
    margin-bottom: 20px;
    overflow: hidden;
  }

  .progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #1b6ef3, #34d399);
    transition: width 0.3s;
    border-radius: 2px;
  }

  .progress-bar.indeterminate {
    width: 60%;
    animation: pulse 1.5s ease-in-out infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.4; }
    50% { opacity: 1; }
  }

  .log {
    background: #0d1220;
    border: 1px solid #151d2e;
    border-radius: 4px;
    padding: 12px;
    margin-bottom: 20px;
    max-height: 160px;
    overflow: auto;
    font-size: 11px;
    line-height: 1.7;
  }

  .log-line { color: #4a6fa5; }
  .log-line.ok { color: #34d399; }
  .log-line.err { color: #e05555; }

  .error-box {
    background: #1a0a0a;
    border: 1px solid #3a1515;
    border-radius: 4px;
    padding: 12px;
    margin-bottom: 20px;
    font-size: 12px;
    color: #e05555;
  }

  .table-wrap {
    border: 1px solid #151d2e;
    border-radius: 4px;
    overflow: auto;
    max-height: 50vh;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 11px;
  }

  th {
    padding: 8px 10px;
    text-align: left;
    border-bottom: 1px solid #1e2d44;
    color: #4a6fa5;
    font-weight: 600;
    position: sticky;
    top: 0;
    background: #0d1220;
    white-space: nowrap;
    z-index: 1;
  }

  td {
    padding: 6px 10px;
    border-bottom: 1px solid #111827;
    white-space: nowrap;
    max-width: 220px;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  tr.even { background: transparent; }
  tr.odd { background: #0c1019; }
  tr.clickable { cursor: pointer; }
  tr.clickable:hover { background: #111827; }

  .expanded-cell {
    padding: 12px;
    background: #0d1220;
    border-bottom: 1px solid #151d2e;
  }

  .expanded-cell pre {
    margin: 0;
    font-size: 10px;
    color: #7a8ea8;
    white-space: pre-wrap;
    word-break: break-all;
    font-family: inherit;
  }

  .table-footer {
    padding: 12px;
    font-size: 11px;
    color: #3d5a80;
    text-align: center;
  }

  .hidden { display: none; }

  ::-webkit-scrollbar { width: 6px; height: 6px; }
  ::-webkit-scrollbar-track { background: #0a0e17; }
  ::-webkit-scrollbar-thumb { background: #1e2d44; border-radius: 3px; }
</style>
</head>
<body>

<div class="label">Ground Truth Nashville</div>
<h1>Eviction State Fetcher</h1>
<div class="url" id="apiUrl"></div>

<div class="controls">
  <button class="btn-primary" id="btnFetch" onclick="fetchAll()">Fetch All Pages</button>
  <button class="btn-stop hidden" id="btnStop" onclick="stopFetch()">Stop</button>
  <button class="btn-ghost hidden" id="btnJSON" onclick="exportJSON()">Export JSON</button>
  <button class="btn-ghost hidden" id="btnCSV" onclick="exportCSV()">Export CSV</button>
</div>

<div class="status-bar">
  <span>Status: <span id="statusText" class="val">Ready</span></span>
  <span>Records: <span id="recordCount" class="val">0</span></span>
</div>

<div class="progress-wrap hidden" id="progressWrap">
  <div class="progress-bar indeterminate" id="progressBar"></div>
</div>

<div class="log hidden" id="logBox"></div>
<div class="error-box hidden" id="errorBox"></div>
<div class="table-wrap hidden" id="tableWrap">
  <table>
    <thead id="thead"></thead>
    <tbody id="tbody"></tbody>
  </table>
  <div class="table-footer hidden" id="tableFooter"></div>
</div>

<script>
const API_BASE = "https://xvkq-pq7i-idtl.n7d.xano.io/api:3CsVHkZK/eviction_current_state";
const PER_PAGE = 2500;
const MAX_TABLE_ROWS = 200;

let records = [];
let abortController = null;
let expandedRow = null;
let columns = [];

document.getElementById("apiUrl").textContent = API_BASE;

function $(id) { return document.getElementById(id); }
function show(id) { $(id).classList.remove("hidden"); }
function hide(id) { $(id).classList.add("hidden"); }

function addLog(msg) {
  show("logBox");
  const div = document.createElement("div");
  div.className = "log-line" + (msg.includes("\u2713") ? " ok" : msg.includes("\u2717") ? " err" : "");
  div.textContent = new Date().toLocaleTimeString() + " \u2014 " + msg;
  $("logBox").appendChild(div);
  $("logBox").scrollTop = $("logBox").scrollHeight;
}

function truncate(val, len) {
  if (val === null || val === undefined) return "\u2014";
  const s = typeof val === "object" ? JSON.stringify(val) : String(val);
  return s.length > len ? s.slice(0, len) + "\u2026" : s;
}

function setStatus(text, cls) {
  const el = $("statusText");
  el.textContent = text;
  el.className = "val " + (cls || "");
}

function updateTable() {
  if (records.length === 0) return;

  if (columns.length === 0) {
    columns = Object.keys(records[0]).slice(0, 8);
    $("thead").innerHTML = "<tr><th>#</th>" +
      columns.map(c => `<th>${c}</th>`).join("") +
      "<th>\u2026</th></tr>";
  }

  show("tableWrap");
  const display = records.slice(0, MAX_TABLE_ROWS);
  $("tbody").innerHTML = display.map((r, i) => {
    const cls = (i % 2 === 0 ? "even" : "odd") + " clickable";
    const arrow = expandedRow === i ? "\u25B2" : "\u25BC";
    let row = `<tr class="${cls}" onclick="toggleRow(${i})">` +
      `<td>${i + 1}</td>` +
      columns.map(c => {
        const val = r[c];
        const est = (c === "fileDate" && r._fileDateEstimated);
        const display = truncate(val, 40);
        return est
          ? `<td style="color:#f5c542" title="Estimated from neighbors">~${display}</td>`
          : `<td>${display}</td>`;
      }).join("") +
      `<td style="color:#3d5a80">${arrow}</td></tr>`;
    if (expandedRow === i) {
      row += `<tr><td colspan="${columns.length + 2}" class="expanded-cell"><pre>${JSON.stringify(r, null, 2)}</pre></td></tr>`;
    }
    return row;
  }).join("");

  if (records.length > MAX_TABLE_ROWS) {
    show("tableFooter");
    $("tableFooter").textContent = `Showing ${MAX_TABLE_ROWS} of ${records.length.toLocaleString()} records. Export to see all.`;
  }
}

function toggleRow(i) {
  expandedRow = expandedRow === i ? null : i;
  updateTable();
}

async function fetchAll() {
  records = [];
  columns = [];
  expandedRow = null;
  $("logBox").innerHTML = "";
  $("thead").innerHTML = "";
  $("tbody").innerHTML = "";
  hide("errorBox");
  hide("tableFooter");

  $("btnFetch").disabled = true;
  show("btnStop");
  hide("btnJSON");
  hide("btnCSV");
  show("progressWrap");

  $("recordCount").textContent = "0";

  abortController = new AbortController();
  let offset = 0;
  let keepGoing = true;
  let itemsTotal = null;
  const MAX_FETCHES = 500;
  let fetchCount = 0;

  try {
    while (keepGoing && fetchCount < MAX_FETCHES) {
      if (abortController.signal.aborted) break;
      fetchCount++;

      const url = `${API_BASE}?offset=${offset}&per_page=${PER_PAGE}`;
      addLog(`Fetching offset ${offset}...`);
      setStatus(`${records.length.toLocaleString()}${itemsTotal ? " / " + itemsTotal.toLocaleString() : ""} records`, "fetching");

      let res, data;
      const MAX_RETRIES = 3;
      for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
        try {
          res = await fetch(url, { signal: abortController.signal });
          if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);
          data = await res.json();
          break;
        } catch (fetchErr) {
          if (fetchErr.name === "AbortError") throw fetchErr;
          if (attempt < MAX_RETRIES) {
            const wait = attempt * 2000;
            addLog(`Retry ${attempt}/${MAX_RETRIES} in ${wait / 1000}s \u2014 ${fetchErr.message}`);
            await new Promise(r => setTimeout(r, wait));
          } else {
            throw fetchErr;
          }
        }
      }

      // Xano paginated wrapper
      if (data && typeof data === "object" && !Array.isArray(data) && Array.isArray(data.items)) {
        const items = data.items;
        const received = items.length;
        records.push(...items);

        if (data.itemsTotal) itemsTotal = data.itemsTotal;
        const perPage = data.perPage || PER_PAGE;

        // Progress based on records collected vs total
        if (itemsTotal) {
          const pct = Math.min((records.length / itemsTotal) * 100, 100);
          $("progressBar").classList.remove("indeterminate");
          $("progressBar").style.width = pct + "%";
        }

        addLog(`Got ${received} records (${records.length.toLocaleString()}${itemsTotal ? " / " + itemsTotal.toLocaleString() : ""})`);

        // PRIMARY stop: collected enough records
        if (received === 0
            || (itemsTotal && records.length >= itemsTotal)) {
          keepGoing = false;
        } else {
          offset += received;
        }
      }
      // Plain array
      else if (Array.isArray(data)) {
        records.push(...data);
        addLog(`Got ${data.length} records (${records.length.toLocaleString()})`);
        if (data.length === 0 || data.length < PER_PAGE) {
          keepGoing = false;
        } else {
          offset += data.length;
        }
      }
      // Unknown
      else {
        addLog(`Unexpected response shape. Keys: ${Object.keys(data || {}).join(", ")}`);
        addLog(`Raw: ${JSON.stringify(data).slice(0, 500)}`);
        keepGoing = false;
      }

      $("recordCount").textContent = records.length.toLocaleString();
      updateTable();

      if (keepGoing) await new Promise(r => setTimeout(r, 1000));
    }

    addLog(`\u2713 Fetched ${records.length.toLocaleString()} records. Inferring missing fileDates...`);
    inferMissingFileDates();
    addLog(`\u2713 Complete.`);
    setStatus("Complete", "done");
  } catch (err) {
    if (err.name === "AbortError") {
      addLog("Fetch cancelled by user.");
      setStatus("Stopped", "");
    } else {
      addLog(`\u2717 Error: ${err.message}`);
      setStatus("Error", "error");
      $("errorBox").textContent = err.message;
      show("errorBox");
    }
  }

  $("btnFetch").disabled = false;
  hide("btnStop");
  hide("progressWrap");

  if (records.length > 0) {
    show("btnJSON");
    show("btnCSV");
  }
}

function parseDocket(dn) {
  // e.g. "25GT14532" -> { prefix: "25GT", seq: 14532 }
  // e.g. "26GT625"   -> { prefix: "26GT", seq: 625 }
  const m = dn && dn.match(/^(\d{2}[A-Z]+)(\d+)$/i);
  if (!m) return null;
  return { prefix: m[1].toUpperCase(), seq: parseInt(m[2], 10) };
}

function inferMissingFileDates() {
  // 1. Parse all docket numbers and collect known fileDate anchors per prefix group
  const parsed = records.map((r, i) => ({
    idx: i,
    docket: parseDocket(r.docket_number),
    fileDate: r.fileDate || null,
  }));

  // Group by prefix (e.g. "25GT", "26GT")
  const groups = {};
  for (const p of parsed) {
    if (!p.docket) continue;
    const key = p.docket.prefix;
    if (!groups[key]) groups[key] = [];
    groups[key].push(p);
  }

  let filled = 0;
  let skipped = 0;

  for (const [prefix, items] of Object.entries(groups)) {
    // Sort by sequence number
    items.sort((a, b) => a.docket.seq - b.docket.seq);

    // Collect anchors: items with known fileDate
    const anchors = [];
    for (const item of items) {
      if (item.fileDate != null) {
        // fileDate could be epoch ms (number), epoch string, or date string
        let ts;
        if (typeof item.fileDate === "number") {
          ts = item.fileDate;
        } else if (typeof item.fileDate === "string") {
          const n = Number(item.fileDate);
          if (!isNaN(n) && item.fileDate.length >= 10) {
            ts = n;
          } else {
            ts = new Date(item.fileDate).getTime();
          }
        }
        if (ts && !isNaN(ts)) {
          anchors.push({ seq: item.docket.seq, ts });
        }
      }
    }

    if (anchors.length === 0) {
      skipped += items.filter(i => !i.fileDate).length;
      continue;
    }

    // Sort anchors by seq
    anchors.sort((a, b) => a.seq - b.seq);

    // 2. For each item missing fileDate, interpolate from nearest anchors
    for (const item of items) {
      if (item.fileDate != null) continue;
      const seq = item.docket.seq;

      // Find the anchor just below and just above
      let below = null, above = null;
      for (let i = 0; i < anchors.length; i++) {
        if (anchors[i].seq <= seq) below = anchors[i];
        if (anchors[i].seq >= seq && above === null) above = anchors[i];
      }

      let estimatedTs;
      if (below && above && below.seq !== above.seq) {
        // Linear interpolation
        const frac = (seq - below.seq) / (above.seq - below.seq);
        estimatedTs = below.ts + frac * (above.ts - below.ts);
      } else if (below) {
        estimatedTs = below.ts;
      } else if (above) {
        estimatedTs = above.ts;
      } else {
        continue;
      }

      // Store as epoch ms (same format), flag as estimated
      const estDate = new Date(Math.round(estimatedTs));
      // Write back to the record -- store as ISO string with marker
      records[item.idx].fileDate = estDate.toISOString().slice(0, 10);
      records[item.idx]._fileDateEstimated = true;
      filled++;
    }

    addLog(`[${prefix}] ${anchors.length} anchors \u2192 inferred ${items.filter(i => records[i.idx]._fileDateEstimated).length} dates`);
  }

  addLog(`fileDate: ${filled} inferred, ${skipped} skipped (no anchors in group)`);
  updateTable();
}

function stopFetch() {
  if (abortController) abortController.abort();
}

function exportJSON() {
  const blob = new Blob([JSON.stringify(records, null, 2)], { type: "application/json" });
  dl(blob, `eviction_data_${today()}.json`);
}

function exportCSV() {
  if (!records.length) return;
  const keys = Object.keys(records[0]);
  const lines = [
    keys.join(","),
    ...records.map(r =>
      keys.map(k => {
        const v = r[k];
        const s = v == null ? "" : String(v);
        return (s.includes(",") || s.includes('"') || s.includes("\n"))
          ? `"${s.replace(/"/g, '""')}"` : s;
      }).join(",")
    )
  ];
  const blob = new Blob([lines.join("\n")], { type: "text/csv" });
  dl(blob, `eviction_data_${today()}.csv`);
}

function dl(blob, name) {
  const a = document.createElement("a");
  a.href = URL.createObjectURL(blob);
  a.download = name;
  a.click();
  URL.revokeObjectURL(a.href);
}

function today() {
  return new Date().toISOString().slice(0, 10);
}
</script>
</body>
</html>
